import{_ as s,c as a,a as l,o as e}from"./app-DOVazbfl.js";const i={};function t(p,n){return e(),a("div",null,[...n[0]||(n[0]=[l(`<h3 id="浏览器渲染" tabindex="-1"><a class="header-anchor" href="#浏览器渲染"><span>浏览器渲染</span></a></h3><blockquote><p>浏览器渲染页面前的步骤</p></blockquote><ol><li>解析HTML，生成DOM树 <ul><li>DOM树表示了网页的结构，包括各个HTML元素（如段落、标题、链接等）以及它们之间的层次关系。</li></ul></li><li>解析css代码, 生成CSS树 <ul><li>浏览器计算每个DOM元素的最终样式，这包括了处理CSS选择器、继承样式和层叠规则等。</li></ul></li><li>DOM树和CSS树合并在一块生成Render树 <ul><li>渲染树仅包括需要在屏幕上渲染的元素，不包括隐藏的元素。这个树的结构与DOM树类似，但只包含影响页面布局和外观的元素。</li></ul></li><li>布局 <ul><li>浏览器确定每个元素的坐标、宽度、高度等信息，以便正确显示在屏幕上。</li></ul></li><li>绘制 <ul><li>一旦页面的布局信息计算完成，浏览器开始将页面内容绘制到屏幕上。这包括绘制文本、图像、背景颜色等，以及处理透明度和层叠等效果</li></ul></li></ol><h4 id="dom树原则" tabindex="-1"><a class="header-anchor" href="#dom树原则"><span>DOM树原则</span></a></h4><blockquote><p>深度优先</p></blockquote><ol><li>是的，DOM树的遍历原则通常是深度优先遍历（Depth-First Traversal）。深度优先遍历意味着浏览器会首先访问DOM树的最深的节点，然后再逐层向上遍历。这种遍历方式有助于浏览器快速找到目标节点并执行相应的操作。</li><li>在深度优先遍历中，浏览器会首先访问当前节点的第一个子节点（如果有子节点的话），然后再访问该子节点的子节点，以此类推，直到遍历到叶子节点。然后，浏览器回溯到上一级节点，继续遍历其他子节点，直到遍历完整个DOM树。</li><li>深度优先遍历在许多DOM操作和JavaScript事件处理中都非常有用，因为它可以帮助快速找到目标节点，并且通常更高效。但需要注意，深度优先遍历可能会导致性能问题，特别是在非常深的DOM树中，因为它可能需要递归访问许多节点。因此，在进行DOM操作时，应注意优化代码以避免不必要的遍历。</li></ol><h3 id="重构和重绘" tabindex="-1"><a class="header-anchor" href="#重构和重绘"><span>重构和重绘</span></a></h3><ol><li>重排（Reflow）是浏览器重新计算页面布局并更新元素位置和大小的过程。它通常是由于以下原因之一触发的 <ul><li>DOM结构变化：当您通过JavaScript修改了页面的DOM结构，例如添加、删除或修改元素，浏览器需要重新计算布局，以确保元素正确显示在屏幕上。</li><li>CSS样式变化：如果您修改了元素的CSS样式，例如改变元素的宽度、高度、边距、字体大小等，浏览器也需要重新计算布局，以适应新的样式。</li><li>浏览器窗口大小变化：当用户调整浏览器窗口大小时，页面布局可能会发生变化，因此浏览器需要重新计算布局以适应新的窗口大小。</li><li>字体加载：如果网页中使用了自定义字体，当字体加载完成后，浏览器需要重新计算文本元素的布局，以确保使用正确的字体显示文本内容。</li></ul></li><li>重绘（Repaint）是浏览器中的一个操作，它涉及重新绘制页面元素的外观，但不涉及改变元素的位置或大小。重绘通常发生在以下情况下 <ul><li>CSS样式变化：当您修改了元素的CSS样式，例如颜色、背景、字体等，而这些样式的改变只影响元素的外观而不影响布局时，浏览器会触发重绘。</li><li>文本内容变化：当文本内容发生变化时，浏览器需要重新绘制文本元素以反映新的内容，但不需要重新计算布局。</li><li>滚动：当用户滚动页面时，页面上的可见内容会根据滚动位置而发生变化，浏览器需要重绘可见区域内的元素。</li><li>悬浮效果和伪类状态变化：例如鼠标悬停在链接上时，链接可能会改变颜色或下划线，这会触发链接元素的重绘。</li></ul></li></ol><h4 id="重排和重绘性能" tabindex="-1"><a class="header-anchor" href="#重排和重绘性能"><span>重排和重绘性能</span></a></h4><blockquote><p>重排是一个相对昂贵的操作，因为它会触发整个页面布局的重新计算，涉及到计算元素的尺寸和位置等信息。因此，频繁的重排操作会降低页面的性能和响应速度。</p></blockquote><p>为了减少重排的发生，您可以采取以下措施：</p><ol><li><p>使用CSS类一次性应用样式：避免在JavaScript中逐个修改元素的样式属性，而是使用CSS类，然后在需要时一次性将这些类应用到元素上。</p></li><li><p>批量处理DOM操作：如果需要进行多个DOM操作，尽量将它们组合在一起，然后一次性执行，而不是每个操作都触发一次重排。</p></li><li><p>避免频繁查询布局信息：每次查询元素的尺寸或位置信息（例如使用offsetWidth或offsetTop属性）都会触发重排，因此尽量减少这类查询。</p></li><li><p>使用requestAnimationFrame：如果需要执行一些可能触发重排的动画效果，使用requestAnimationFrame来进行动画处理，浏览器会在下一帧渲染之前批量处理所有动画操作，减少重排的次数。</p></li></ol><p>通过谨慎处理DOM操作和样式变化，可以有效减少重排的发生，提高页面性能和响应速度。</p><h3 id="同步加载" tabindex="-1"><a class="header-anchor" href="#同步加载"><span>同步加载</span></a></h3><ol><li>js的加载是同步的;</li><li>同步加载js 是为了防止js操作DOM元素,而造成问题, Dom在加载的时候 去操作Dom</li><li>执行按照从上往下一次读取,没有获取到元素节点是因为元素还没有生成</li></ol><h3 id="异步加载" tabindex="-1"><a class="header-anchor" href="#异步加载"><span>异步加载</span></a></h3><p><img src="https://img-blog.csdn.net/20180223183211598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU1MzQ4MjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>蓝色加载 红色执行</p><p>1.defer 只兼容IE9一下可以用 w3c 先读取 文档加载完毕在执行</p><p>2.async 兼容IE9以上都可以用,IE9及其以下不能用 读取之后就执行</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span> <span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">script<span class="token punctuation">.</span>type <span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span></span>
<span class="line">script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;./1.js&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">//IE是一样的</span></span>
<span class="line">window<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">	document<span class="token punctuation">.</span>body <span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="浏览器执行web顺序" tabindex="-1"><a class="header-anchor" href="#浏览器执行web顺序"><span>浏览器执行web顺序</span></a></h3><p>js浏览器执行的事,记录浏览器执行的顺序</p><ol><li>创建document对象。 <ul><li>解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = &#39;loading&#39;。</li></ul></li><li>如果遇到link外部css文件，浏览器会创建新线程加载，同时继续解析文档。 异步,</li><li>如果遇到外部js文件，并且没有设置async、defer，浏览器会加载js文件,阻塞主线程，等待js文件加载完成并执行该文件，然后继续解析文档。</li><li>如果遇到外部js文件，并且设置有async、defer，浏览器会创建新线程加载js文件，同时继续解析文档。 defer会等到所有文档都解析完毕了以后才会执行这行js文件 async属性的js文件，会在js文件加载完成后立即执行,执行期间造成运行堵塞</li><li>如果遇到img,iframe等，浏览器在解析dom结构时，会异步加载src，同时继续解析文档。</li><li>当DOM文档解析完成，document.readyState = &#39;interactive’。</li><li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。</li><li>document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li><li>当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = &#39;complete&#39;，window对象触发load事件</li><li>从此,以异步响应方式处理用户输入,网络事件等</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token string">&quot;loading&quot;</span>：表示文档正在加载中。这是默认状态，通常在页面刚开始加载时出现。</span>
<span class="line"></span>
<span class="line"><span class="token string">&quot;interactive&quot;</span>：表示文档已经解析完毕，<span class="token constant">DOM</span> 树已经构建完成，但资源如样式表和图像等可能仍在加载中。这个状态通常在 DOMContentLoaded 事件触发之前。</span>
<span class="line"></span>
<span class="line"><span class="token string">&quot;complete&quot;</span>：表示文档和所有资源都已经加载完成。这个状态通常在 load 事件触发之前。</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="alert页面不显示内容" tabindex="-1"><a class="header-anchor" href="#alert页面不显示内容"><span>alert页面不显示内容</span></a></h3><ol><li><p>CSS阻塞JS的执行 （因为GUI线程和JS线程是互斥的，因为有可能JS会操作CSS）</p></li><li><p>直接引入的JS会阻塞页面的渲染（GUI线程和JS线程互斥）</p></li></ol>`,28)])])}const o=s(i,[["render",t]]),r=JSON.parse('{"path":"/javaScript/%E6%97%B6%E9%97%B4%E7%BA%BF_%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"浏览器渲染","slug":"浏览器渲染","link":"#浏览器渲染","children":[]},{"level":3,"title":"重构和重绘","slug":"重构和重绘","link":"#重构和重绘","children":[]},{"level":3,"title":"同步加载","slug":"同步加载","link":"#同步加载","children":[]},{"level":3,"title":"异步加载","slug":"异步加载","link":"#异步加载","children":[]},{"level":3,"title":"浏览器执行web顺序","slug":"浏览器执行web顺序","link":"#浏览器执行web顺序","children":[]},{"level":3,"title":"alert页面不显示内容","slug":"alert页面不显示内容","link":"#alert页面不显示内容","children":[]}],"git":{},"filePathRelative":"javaScript/时间线,异步加载.md"}');export{o as comp,r as data};
