import{_ as l,c as n,a as s,o as i}from"./app-DLp8zu_T.js";const a={};function c(o,e){return i(),n("div",null,[...e[0]||(e[0]=[s(`<h2 id="弹性盒模型" tabindex="-1"><a class="header-anchor" href="#弹性盒模型"><span>弹性盒模型</span></a></h2><p>用于布局和排列元素的 CSS 布局模型。它提供了一种灵活的方式来创建自适应和响应式的布局，使元素能够根据可用空间自动调整其大小和位置</p><p>使用弹性盒模型: <code>display: flex</code>，您可以将容器元素定义为弹性容器，并将其子元素定义为弹性项</p><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><p>任何一个容器都可以指定为 Flex 布局, 元素添加 <code>display: flex;</code> 或者 <code>display: inline-flex;</code> 。</p><p>其子元素则可按照弹性盒模型的规则进行布局。</p><p><strong>注意</strong>，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效</p><ul><li>display:flex; 容器本身不会变化，子元素会变成行内块元素</li><li>display: inline-flex; 容器本身变成行内块元素，子元素变成行内块元素，并且自动换行</li></ul><img src="https://api2.mubu.com/v3/document_image/f6bf3038-b2c4-412a-a49a-c04c2a40961a-7637318.jpg" referrerpolicy="no-referrer"><p>设置弹性盒模型</p><ul><li><p>默认会将所有的子元素并排成一行,自动分配空间,</p></li><li><p>子元素宽度默认为0, 默认继承父元素的高度</p></li><li><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）</p></li><li><p>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；</p></li><li><p>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code></p></li><li><p>项目默认沿主轴排列</p></li></ul><h2 id="容器的属性" tabindex="-1"><a class="header-anchor" href="#容器的属性"><span>容器的属性</span></a></h2><p><code>flex-direction</code> 属性决定主轴的方向(内部元素的排列方式)</p><ul><li>flex-direction: row | row-reverse | column | column-reverse;</li><li>flex-direction：从左到右、从右到左、从上到下、从下到上；</li></ul><img src="https://api2.mubu.com/v3/document_image/bd31f228-7766-4042-8a5d-4d4c0b8fabaf-7637318.jpg" referrerpolicy="no-referrer"><p><code>flex-wrap </code> 交叉轴换行(子元素的换行方式)</p><ul><li>flex-wrap: nowrap | wrap | wrap-reverse;</li><li>flex-wrap：不换行 | 换行 第一行在上面| 换行，第二行在上面</li></ul><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a6cbcddc5df415dba18a4ef276f49af~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" referrerpolicy="no-referrer"><p><code>flex-flow属性</code> 主轴和交叉轴换行复合写法</p><ul><li><p>flex-flow:主轴 交叉轴<code>justify-content属性</code> 设置子元素的水平对齐方式</p></li><li><p>justify-<strong>content</strong>: flex-<strong>start</strong> | flex-end | center | space-between | space-around;</p></li><li><p><code>flex-start</code>（默认值）：主轴开始位置对齐；</p></li><li><p><code>flex-end</code>：<strong>主轴结束位置对齐</strong></p></li><li><p><code>center</code>： <strong>居中</strong>；</p></li><li><p><code>space-between</code>：<strong>两端对齐</strong>，项目之间的<strong>间隔都相等</strong>；</p><ul><li>子元素之间留有空隙的像素值: (父元素宽度-每一行子元素宽度之和 ) / 一行子元素个数之和-1</li></ul></li><li><p><code>space-around</code>：每个项目两侧的<strong>间隔相等</strong>。所以，项目之间的间隔比项目与边框的间隔大一倍</p><ul><li>子元素和父元素 =( 父元素的宽度-一行子元素宽度之和)/ (2*一行子元素个数)</li><li>子元素之间留有空隙 2*子元素和父元素间隙</li></ul></li><li><p>space-evenly: 平分间隙;</p><ul><li>父子间隙 和 子元素之间空隙 相等</li></ul></li></ul><img src="https://api2.mubu.com/v3/document_image/0f52a844-4779-4b11-9d9b-7443d1f20544-7637318.jpg" referrerpolicy="no-referrer"><p><code>align-content</code>：设置多个主轴时在交叉轴上的对齐方式；</p><ul><li>align-content: flex-start | flex-end | center | space-between | space-around | stretch</li><li>flex-start：与交叉轴的起点对齐（顶部对齐）</li><li>flex-end：与交叉轴的终点对齐（底部对齐）</li><li>center：与交叉轴的中点对齐（居中对齐）</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布；</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍；</li><li>space-evenly:</li></ul><img src="https://api2.mubu.com/v3/document_image/1b2984b8-3f05-4315-b051-c98f16e9fafa-7637318.jpg" referrerpolicy="no-referrer"><p><code>align-items属性 </code> 设置子元素单行垂直对齐方式</p><ul><li>align-items: flex-start | flex-end | center | baseline | stretch;</li><li>flex-start：交叉轴的起点对齐（顶部对齐）；</li><li>flex-end：交叉轴的终点对齐（底部对齐）</li><li>center：交叉轴的中点对齐（垂直对齐）；</li><li>baseline: 项目的第一行文字的基线对齐（基于内部第一行文字对齐）</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度（高度占满整个容器）；</li></ul><img src="https://api2.mubu.com/v3/document_image/e4b1484b-806d-48d8-af04-418cf62ca75e-7637318.jpg" referrerpolicy="no-referrer"><p><code>align-self属性</code> <strong>单独设置特定元素的对齐方式</strong></p><ul><li>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</li><li>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性</li><li>align-self: auto | flex-start | flex-end | center | baseline | stretch;</li></ul><h2 id="弹性项属性" tabindex="-1"><a class="header-anchor" href="#弹性项属性"><span>弹性项属性</span></a></h2><p><code>order属性</code> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p><ul><li><strong>按照数字大小设置各个子元素之间的排列方式</strong></li></ul><p><code>flex-grow属性</code> 定义项目的<strong>放大</strong>比例，默认为<code>0</code>，即如果存在剩余空间，也不放大</p><ul><li><strong>按照权重分配剩余空间进行等比例放大</strong></li><li>元素1的实际 = 元素1的宽度(100px) + (父元素宽度-子元素之和)*元素1的弹性增长因子/子元素弹性因子和 = 100+(500-400)*1/1 = 200</li></ul><p><code>flex-shrink属性</code> 定义了项目的<strong>缩小</strong>比例，默认为1，即如果空间不足，该项目将缩小</p><ul><li><strong>按照权重进行等比例缩小</strong></li><li>元素1的实际=元素1的宽度(150px) - (子元素宽之和 - 父元素宽度)*元素1弹性缩放因子/缩放因子之和</li></ul><p><code>flex 属性</code> <strong>是设置放大、缩小和原始大小的简写</strong></p><ul><li>flex: none 设置多少就是多少 不扩张 不缩小</li><li>flex: auto 存在剩余空间扩大 没有剩余空间缩小</li><li>flex: flex-grow flex-shrink</li></ul><div class="language-css line-numbers-mode" data-highlighter="prismjs" data-ext="css"><pre><code><span class="line"><span class="token selector">.item</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token property">order</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span></span>
<span class="line">    <span class="token property">flex-grow</span><span class="token punctuation">:</span> 2<span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token property">flex-shrink</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span></span>
<span class="line">    <span class="token property">flex</span><span class="token punctuation">:</span> none</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,39)])])}const t=l(a,[["render",c]]),p=JSON.parse('{"path":"/htmlcss/15-%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"弹性盒模型","slug":"弹性盒模型","link":"#弹性盒模型","children":[]},{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"容器的属性","slug":"容器的属性","link":"#容器的属性","children":[]},{"level":2,"title":"弹性项属性","slug":"弹性项属性","link":"#弹性项属性","children":[]}],"git":{},"filePathRelative":"htmlcss/15-弹性盒模型.md"}');export{t as comp,p as data};
